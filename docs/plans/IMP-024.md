# IMP-024 — Options chain snapshots → normalized calls/puts + raw payload (Alpaca)

- **Status:** done (2026-02-04)
- **Effort:** M
- **Alpha potential:** Very High

## Summary
Implement Alpaca options-chain fetching in a way that is compatible with existing repo workflows:
- `get_options_chain()` returns `OptionsChain(calls, puts)` DataFrames
- `get_options_chain_raw()` returns a dict with `calls`, `puts`, `underlying`, and optionally full raw payloads

This unlocks:
- `options_snapshotter.snapshot_full_chain_for_symbols(...)` running end-to-end with Alpaca
- option selection + quote-quality scoring using higher quality quotes than Yahoo

## Goals
- Implement `MarketDataProvider.get_options_chain()` and `.get_options_chain_raw()` for Alpaca.
- Ensure the returned rows include at least the repo’s normalized option-chain schema:
  - `contractSymbol`, `strike`, `bid`, `ask`, `lastPrice`, `impliedVolatility`, `openInterest`, `volume`, plus `expiry`, `optionType`
- Join contract metadata from IMP-023 to populate `strike`, `optionType`, and `openInterest`.

## Non-goals
- Accurate “today volume” population (IMP-025).
- Intraday quote/trade history (IMP-027).
- Perfect greeks parity vs Alpaca; we store Alpaca greeks opportunistically as *optional columns*.

## User-facing changes
- `options-helper --provider alpaca snapshot ...` produces snapshots and raw payloads using Alpaca data.
- Snapshot CSVs will include richer quote fields where available:
  - `lastTradeDate` should be filled from latest trade timestamps (improves staleness scoring).

## Design
### Data sources
- Use Alpaca Market Data “option chain” endpoint via `OptionHistoricalDataClient.get_option_chain(...)`
  with an `OptionChainRequest` filtered by:
  - `underlying_symbol`
  - `expiration_date=expiry` (critical: keeps payload small)
  - `feed` based on env/config (opra vs indicative)
- Join with contract metadata cache from IMP-023:
  - provides strike/type and (stale but useful) open interest fields

### Output mapping
For each contract snapshot:
- `contractSymbol`: Alpaca option symbol (OSI-like)
- `bid` / `ask`: from `latest_quote`
- `lastPrice`: from `latest_trade`
- `lastTradeDate`: timestamp from `latest_trade`
- `impliedVolatility`: from snapshot `implied_volatility`
- Optional greeks:
  - `delta`, `gamma`, `theta`, `vega`, `rho` (when present)
- Join-in fields from contracts:
  - `strike`, `optionType`, `openInterest`, `openInterestDate`

### Raw payload format contract (required by current snapshotter)
`options_helper/data/options_snapshotter.py` expects:
```py
raw = provider.get_options_chain_raw(sym, exp)
calls = pd.DataFrame(raw.get("calls", []))
puts = pd.DataFrame(raw.get("puts", []))
underlying = raw.get("underlying", {})
```
So Alpaca provider must return:
```json
{
  "underlying": { ... },
  "calls": [ {...}, ... ],
  "puts":  [ {...}, ... ],
  "provider_raw": { ... optional full raw ... }
}
```

## Implementation plan
### Step 1 — Add option chain fetch in `AlpacaClient`
**Files:**
- `options_helper/data/alpaca_client.py`

**Work:**
- Add `get_option_chain_snapshots(underlying, *, expiry, feed) -> dict[str, Any]`
  - Build `OptionChainRequest(underlying_symbol=..., expiration_date=..., feed=...)`
  - Call `OptionHistoricalDataClient.get_option_chain(...)`
  - Return either wrapped objects or raw dicts (pick one, but keep deterministic)
- Add `option_chain_to_rows(...) -> list[dict]` to flatten snapshots into rows.

### Step 2 — Provider integration: `get_options_chain_raw`
**Files:**
- `options_helper/data/providers/alpaca.py`
- `options_helper/data/option_contracts.py` (from IMP-023)

**Work:**
- Fetch chain snapshots for the underlying+expiry.
- Load (or fetch) contracts table for that underlying (IMP-023) and join by `contractSymbol`.
- Split into calls/puts using `optionType` from contracts (preferred) or by parsing `contractSymbol` (fallback).
- Emit:
  - `raw["calls"]` / `raw["puts"]` as lists of dicts with normalized fields
  - `raw["underlying"]`:
    - include at least `symbol`, `spot` (if fetched), and any stock snapshot raw fields if cheap to obtain.

### Step 3 — Provider integration: `get_options_chain`
**Files:**
- `options_helper/data/providers/alpaca.py`

**Work:**
- Implement by calling `get_options_chain_raw`, building DataFrames, and returning `OptionsChain(...)`.
- Run `normalize_option_chain(...)` on calls and puts (same as YahooProvider does).

## Tests
- `tests/providers/test_alpaca_option_chain_mapping.py` (new)
  - Given a mocked chain snapshot for two contracts + mocked contract metadata:
    - output contains required columns
    - correct call/put split
    - `lastTradeDate` parses as datetime-compatible strings
    - missing greeks do not crash (OTM greeks may be absent)

## Acceptance criteria
- `snapshot_full_chain_for_symbols([...], provider=AlpacaProvider())` can:
  - list expiries
  - fetch raw chains per expiry
  - write snapshot CSV + raw JSON without schema errors
- Required option-chain columns exist in the saved CSV (even if some values are NA).
