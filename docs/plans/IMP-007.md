# IMP-007 — Options backtester using snapshot history (daily)

- **Status:** done
- **Effort:** L
- **Alpha potential:** Very High

## Summary
You already collect the hard part: daily underlying candles + daily option chain snapshots.
Build a **daily-resolution** simulator that can test entry/exit/roll rules using your stored history
(with conservative, spread-aware pricing) and produce performance diagnostics by setup.

This turns the repo from “tools that feel useful” into “tools you can measure and iterate”.

## Goals
- Run deterministic backtests with **no network calls**.
- Support at least one baseline strategy (single-leg long option) and one roll policy.
- Use a conservative execution model:
  - default to “buy at ask / sell at bid”
  - optionally use mark with spread-based slippage (IMP-001)
- Produce artifacts:
  - trade log (CSV/JSON)
  - summary stats (JSON)
  - markdown report (human-readable)

## Non-goals (v1)
- Intraday backtests.
- Assignment/early exercise modeling for American options (warn when relevant).
- Full portfolio optimization / multi-asset correlations.

## User-facing changes
- New command group:
  - `options-helper backtest run ...`
  - `options-helper backtest report ...`
- New artifacts under:
  - `data/reports/backtests/<run_id>/`

## Design
### Data source
- Candles: `CandleStore` daily cache (already offline).
- Options marks: `OptionsSnapshotStore` by date and contract.
- Contract identity:
  - v1: `contractSymbol`
  - v2: OSI normalization (IMP-020)

### Execution model (v1)
- `fill_mode = worst_case | mark_slippage`
  - worst_case: buys pay ask, sells receive bid
  - mark_slippage: mark +/- (spread_pct * slippage_factor)
- If bid/ask missing:
  - mark_slippage falls back to `mark`
  - worst_case becomes `unknown` and the trade is skipped (default) unless overridden

### Accounting model
- Track cash and positions (1 unit per trade for v1).
- For each trade:
  - entry date/price, exit date/price
  - max favorable/adverse excursion (based on daily marks when available)
  - holding period, realized P&L
- Use “premium paid” as max risk for long options (align with portfolio logic).

## Implementation plan (phased)
### Phase 0 — Plumbing + mark series builder
**Deliverables**
- Given `symbol` and `contractSymbol`, build a daily mark series across snapshot dates.
- Handle missing days/contracts cleanly (missing marks -> gaps).

**Files**
- `options_helper/backtesting/` (new package)
  - `data_source.py`
  - `marks.py`

### Phase 1 — Single-leg strategy MVP
**Deliverables**
- Strategy DSL (tiny): a python class with `should_enter(day_ctx)` and `should_exit(pos_ctx)`.
- One built-in example strategy:
  - enter when weekly trend supportive and extension percentile is low-tail
  - exit on stop, take-profit, or time stop

**Files**
- `options_helper/backtesting/strategy.py`
- `options_helper/backtesting/runner.py`
- `docs/BACKTESTING.md` (new)

### Phase 2 — Rolling
**Deliverables**
- Roll trigger: `dte <= roll_dte_threshold` and thesis still supportive.
- Roll selection reuses `analysis/roll_plan.py` with offline snapshots.

**Files**
- `options_helper/backtesting/roll.py`

### Phase 3 — Batch runs + parameter sweeps (optional)
**Deliverables**
- Run across watchlists.
- Evaluate multiple configs and compare.

## Tests
- Commit a tiny fixture dataset (few dates, few contracts) under `tests/fixtures/backtest/`.
- Unit tests:
  - execution pricing behavior (worst_case vs mark_slippage)
  - P&L math
  - roll mechanics
- End-to-end test:
  - `backtest run` on fixture data produces deterministic artifacts.

## Acceptance criteria
- A backtest run on a fixture dataset produces the same trade log every time.
- The execution model is explicit and conservative by default.
- Results are easily comparable across runs (stable schema, run_id, config snapshot).
